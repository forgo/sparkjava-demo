plugins {
    // https://plugins.gradle.org/plugin/io.forgo.keystoreplugin
    id "io.forgo.keystoreplugin" version "1.0"
}

group 'io.forgo.spark'
version '1.0-SNAPSHOT'

description = """\
>\n------------------------------------------------------------
Demo project to show off various Spark Java Framework 
conventions and help bootstrap new projects.
------------------------------------------------------------
Project version: ${version}
Gradle version: ${gradle.gradleVersion}
------------------------------------------------------------
"""

// adds Java compilation along with testing and bundling capabilities
// -> https://docs.gradle.org/current/userguide/java_plugin.html
apply plugin: 'java'

// facilitates creating an executable JVM application
// -> https://docs.gradle.org/current/userguide/application_plugin.html
apply plugin: 'application'

sourceCompatibility = 1.8
mainClassName = "io.forgo.spark.demo.DemoApplication"

defaultTasks 'run'

ext {
    // dependency versioning
    sparkJavaVersion = '2.7.2'
    sparkPac4jVersion = '2.3.0'
    sparkTemplateVelocityVersion = '2.7.1'
    junitVersion = '4.12'
    logbackVersion = '1.2.1'
    snakeYmlVersion = '1.23'

    // keystore file
    keystoreOutputDir = ".keystore"
    keystoreFile = "keystore.jks"
    keystorePassword = "password"
    keystoreAlias = "jetty"

    /* -- build and environment-specific parameters -- */

    // production builds look for this environment variable
    def PRODUCTION = Boolean.valueOf(System.getenv("IO_FORGO_SPARK_DEMO")=="production")

    // local runs (for IDE debug configuration)
    // - to enable, pass `-Ddebug.local=true` to `gradle run`
    def DEBUG_LOCAL = Boolean.valueOf(System.getProperty("debug.local"))

    summary = "Demo project to show off various Spark Java Framework conventions and help bootstrap new projects."
    vendor = "forgo.io"
    buildDate = "${new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone('UTC'))}"
    port = DEBUG_LOCAL ? '4567' : '7713'

    keystoreFileLocalPath = "${keystoreOutputDir}/${keystoreFile}"
    if(PRODUCTION) {
        // TODO: prod should use an actual keystore not generated by plugin
        keystoreFileLocalPath = "${keystoreOutputDir}/${keystoreFile}"
    }

    // for docker images, the keystore file path is /etc/keystore.jks
    keystoreFileDockerPath = "/etc/${keystoreFile}"

    // app YML config pre-processes w/this to find local keystore for non-docker runs
    keystoreFileResolved = DEBUG_LOCAL ? "${keystoreFileLocalPath}" : "${keystoreFileDockerPath}"
}

// URL for the source code under version control from which this container image was built.
ext.getVcsUrl = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        ignoreExitValue = true
        workingDir '.'
        executable = 'git'
        args = ['config', '--get', 'remote.origin.url']
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

// Identifier for the version of the source code from which this image was built.
// For example if the version control system is git this is the SHA.
ext.getVcsRef = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        ignoreExitValue = true
        workingDir '.'
        executable = 'git'
        args = ['rev-parse', '--short', 'HEAD']
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

// keystore plugin readme:
// https://github.com/forgo/keystore-gradle-plugin/blob/master/README.md
keystore {
    outputDir = "${project.keystoreOutputDir}"

    keyFile = "debug.key"
    keyPassword = "${project.keystorePassword}"

    certFile = "debug.crt"

    pkcs12File = "keystore.pkcs12"
    pkcs12Password = "${project.keystorePassword}"

    jksFile = "${project.keystoreFile}"
    jksPassword = "${project.keystorePassword}"
    alias = "${project.keystoreAlias}"
}

// generate fresh keystore for builds
build.dependsOn(jks)

repositories {
    mavenCentral()
}

dependencies {
    compile group: 'com.sparkjava', name: 'spark-core', version: "${project.sparkJavaVersion}"
    compile group: 'org.pac4j', name: 'spark-pac4j', version: "${project.sparkPac4jVersion}"
    compile group: 'com.sparkjava', name: 'spark-template-velocity', version: "${project.sparkTemplateVelocityVersion}"
    compile group: 'ch.qos.logback', name: 'logback-classic', version: "${project.logbackVersion}"
    compile group: 'org.yaml', name: 'snakeyaml', version: "${snakeYmlVersion}"

    testCompile group: 'junit', name: 'junit', version: "${project.junitVersion}"
}

// copies resources from source to target, potentially processing them
processResources {
    // pre-process variables inside config.yml from build properties
    outputs.upToDateWhen { false }
    filesMatching("**/config.yml") {
        expand( project.properties )
    }
}

// create a fat executable jar
jar {
    manifest {
        attributes "Main-Class": "$mainClassName"
    }
    from {
        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
    }
    archiveName "app.jar"
}

task runJar(type: JavaExec, dependsOn: jar) {
    main = "-jar"
    args jar.archivePath
}

task buildDocker(dependsOn: build) {
    doLast {
        def vcsUrl = project.getVcsUrl()
        def vcsRef = project.getVcsRef()
        exec {
            ignoreExitValue = true
            workingDir '.'
            executable = 'docker'
            args = [
                'build',
                '--build-arg', "NAME=${project.name}",
                '--build-arg', "DESCRIPTION=${project.summary}",
                '--build-arg', "VERSION=${version}",
                '--build-arg', "BUILD_DATE=${project.buildDate}",
                '--build-arg', "VENDOR=${project.vendor}",
                '--build-arg', "VCS_URL=${vcsUrl}",
                '--build-arg', "VCS_REF=${vcsRef}",
                '--build-arg', "PORT=${project.port}",
                '--build-arg', "KEYSTORE_SRC=${project.keystoreFileLocalPath}",
                '--build-arg', "KEYSTORE_DST=${project.keystoreFileDockerPath}",
                '-t', "${project.name}:${version}",
                '.'
            ]
        }
    }
}

task runDocker(dependsOn: buildDocker) {
    doLast {
        exec {
            ignoreExitValue = true
            workingDir '.'
            executable = 'docker'
            args = [
                'run',
                '--rm',
                '--name', "${project.name}",
                '-p', "${project.port}:${project.port}",
                "${project.name}:${version}"
            ]
        }
    }
}